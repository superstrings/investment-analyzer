"""
Base strategy class and result types for backtesting.

Provides abstract strategy interface and data classes for backtest results.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Optional

import pandas as pd


class SignalType(str, Enum):
    """Trading signal types."""

    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


class PositionSide(str, Enum):
    """Position side."""

    LONG = "LONG"
    SHORT = "SHORT"
    FLAT = "FLAT"


@dataclass
class Signal:
    """Trading signal generated by a strategy."""

    date: datetime
    signal_type: SignalType
    price: float
    quantity: float = 1.0
    reason: str = ""
    confidence: float = 1.0  # 0.0 to 1.0

    def __post_init__(self):
        if isinstance(self.date, str):
            self.date = pd.to_datetime(self.date)


@dataclass
class Trade:
    """A completed trade (entry + exit)."""

    entry_date: datetime
    entry_price: float
    exit_date: datetime
    exit_price: float
    quantity: float
    side: PositionSide
    pnl: float = 0.0
    pnl_pct: float = 0.0
    holding_days: int = 0
    entry_reason: str = ""
    exit_reason: str = ""

    def __post_init__(self):
        # Calculate PnL if not provided
        if self.pnl == 0.0:
            if self.side == PositionSide.LONG:
                self.pnl = (self.exit_price - self.entry_price) * self.quantity
                self.pnl_pct = (
                    (self.exit_price - self.entry_price) / self.entry_price
                    if self.entry_price > 0
                    else 0
                )
            else:  # SHORT
                self.pnl = (self.entry_price - self.exit_price) * self.quantity
                self.pnl_pct = (
                    (self.entry_price - self.exit_price) / self.entry_price
                    if self.entry_price > 0
                    else 0
                )

        # Calculate holding days
        if self.holding_days == 0:
            if isinstance(self.entry_date, str):
                self.entry_date = pd.to_datetime(self.entry_date)
            if isinstance(self.exit_date, str):
                self.exit_date = pd.to_datetime(self.exit_date)
            self.holding_days = (self.exit_date - self.entry_date).days


@dataclass
class Position:
    """Current open position."""

    entry_date: datetime
    entry_price: float
    quantity: float
    side: PositionSide
    current_price: float = 0.0
    unrealized_pnl: float = 0.0
    entry_reason: str = ""

    def update_price(self, price: float):
        """Update current price and unrealized PnL."""
        self.current_price = price
        if self.side == PositionSide.LONG:
            self.unrealized_pnl = (price - self.entry_price) * self.quantity
        else:
            self.unrealized_pnl = (self.entry_price - price) * self.quantity


@dataclass
class BacktestMetrics:
    """Performance metrics for a backtest."""

    # Returns
    total_return: float = 0.0
    total_return_pct: float = 0.0
    annualized_return: float = 0.0

    # Risk metrics
    max_drawdown: float = 0.0
    max_drawdown_pct: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0

    # Trade statistics
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    win_rate: float = 0.0
    avg_win: float = 0.0
    avg_loss: float = 0.0
    profit_factor: float = 0.0
    avg_holding_days: float = 0.0

    # Risk-adjusted
    max_consecutive_wins: int = 0
    max_consecutive_losses: int = 0
    expectancy: float = 0.0  # Average expected profit per trade


@dataclass
class BacktestResult:
    """Complete backtest result."""

    # Configuration
    strategy_name: str
    symbol: str
    start_date: datetime
    end_date: datetime
    initial_capital: float

    # Final state
    final_capital: float = 0.0
    final_position: Optional[Position] = None

    # Performance
    metrics: BacktestMetrics = field(default_factory=BacktestMetrics)

    # Trade history
    trades: list[Trade] = field(default_factory=list)
    signals: list[Signal] = field(default_factory=list)

    # Equity curve
    equity_curve: list[tuple[datetime, float]] = field(default_factory=list)

    # Daily returns for analysis
    daily_returns: list[float] = field(default_factory=list)


@dataclass
class StrategyConfig:
    """Base configuration for strategies."""

    # Capital management
    initial_capital: float = 100000.0
    position_size: float = 1.0  # Fraction of capital per trade (0.0 to 1.0)
    max_positions: int = 1  # Maximum concurrent positions

    # Risk management
    stop_loss_pct: Optional[float] = None  # e.g., 0.05 for 5%
    take_profit_pct: Optional[float] = None  # e.g., 0.10 for 10%
    trailing_stop_pct: Optional[float] = None

    # Transaction costs
    commission_rate: float = 0.001  # 0.1%
    slippage: float = 0.0  # Price slippage


class Strategy(ABC):
    """Abstract base class for trading strategies."""

    def __init__(self, config: Optional[StrategyConfig] = None):
        """Initialize strategy with configuration.

        Args:
            config: Strategy configuration. Uses defaults if not provided.
        """
        self.config = config or StrategyConfig()
        self.name = self.__class__.__name__

    @abstractmethod
    def generate_signals(self, data: pd.DataFrame) -> list[Signal]:
        """Generate trading signals from price data.

        Args:
            data: DataFrame with OHLCV data. Must have columns:
                  date, open, high, low, close, volume

        Returns:
            List of Signal objects
        """
        pass

    def on_bar(
        self,
        date: datetime,
        open_: float,
        high: float,
        low: float,
        close: float,
        volume: float,
        position: Optional[Position],
    ) -> Optional[Signal]:
        """Process a single bar and optionally generate a signal.

        This is called for each bar during backtesting. Override this
        for strategies that need to track state bar-by-bar.

        Args:
            date: Bar date
            open_: Opening price
            high: High price
            low: Low price
            close: Closing price
            volume: Volume
            position: Current position (if any)

        Returns:
            Signal if one should be generated, None otherwise
        """
        return None

    def should_exit(
        self,
        position: Position,
        current_price: float,
        current_date: datetime,
    ) -> tuple[bool, str]:
        """Check if current position should be exited.

        Args:
            position: Current position
            current_price: Current market price
            current_date: Current date

        Returns:
            Tuple of (should_exit, reason)
        """
        # Check stop loss
        if self.config.stop_loss_pct:
            position.update_price(current_price)
            pnl_pct = position.unrealized_pnl / (
                position.entry_price * position.quantity
            )
            if pnl_pct <= -self.config.stop_loss_pct:
                return True, f"止损 ({pnl_pct:.2%})"

        # Check take profit
        if self.config.take_profit_pct:
            position.update_price(current_price)
            pnl_pct = position.unrealized_pnl / (
                position.entry_price * position.quantity
            )
            if pnl_pct >= self.config.take_profit_pct:
                return True, f"止盈 ({pnl_pct:.2%})"

        return False, ""

    def calculate_position_size(self, capital: float, price: float) -> float:
        """Calculate position size based on available capital.

        Args:
            capital: Available capital
            price: Entry price

        Returns:
            Number of shares/units to trade
        """
        available = capital * self.config.position_size
        return available / price if price > 0 else 0

    def get_parameters(self) -> dict:
        """Get strategy parameters for reporting.

        Returns:
            Dict of parameter name to value
        """
        return {
            "initial_capital": self.config.initial_capital,
            "position_size": self.config.position_size,
            "stop_loss_pct": self.config.stop_loss_pct,
            "take_profit_pct": self.config.take_profit_pct,
            "commission_rate": self.config.commission_rate,
        }
